#!/usr/bin/env sh
# fmt(1) wrapper script

width=80
if [ $# -ge 1 ]; then
	op=$(echo $1 | awk '{ s=substr($0,1,2); print s; }')
	if [ "$op" = "-w" ]; then
		if [ "$1" = "-w" ]; then
			# space between -w and number
			shift
			if [ $# -eq 0 ]; then
				echo "$0: -w requires an argument" 1>&2
				exit 1
			fi
			width="$1"
			shift
		else
			# no space between -w and number
			width=$(echo $1 | awk '{ s=substr($0,3); print s; }')
			shift
		fi
	fi
fi

if [ $# -ne 0 ]; then
	echo "$0: unexpected arguments: $@" 1>&2
	echo "usage: $0 width" 1>&2
	exit 1
fi

# plan9port's fmt(1) and sed(1) aren't compatible with this script, so don't
# use them even if $PLAN9/bin is at the front of the path
fmt=$(no9 which fmt)
sed=$(no9 which sed)

$fmt --version 2>/dev/null | grep GNU >/dev/null
if [ $? -eq 0 ]; then
	# GNU coreutils fmt(1).  Unfortunately, when a line is indented with
	# tabs, GNU's fmt replaces spaces with tabs everywhere on the line:
	# e.g., two spaces after a period may become a tab.  Convert those tabs
	# back into spaces; then if (and only if) the line was indented with
	# tabs, convert the leading indentation back into tabs.
	tmpf=$(mktemp)
	trap 'rm -f -- "$tmpf"' EXIT
	cat >"$tmpf"
	ichar=`sed 1q "$tmpf" | $sed 's/\(.\).*/\1/'`
	postexpand=cat
	if [ "$ichar" = "	" ]; then
		postexpand="unexpand --first-only"
	fi
	# GNU coreutils fmt(1)
	$fmt --uniform-spacing --width=$width --goal=$width <"$tmpf" | \
		expand | $postexpand
else
	# BSD fmt(1)
	$fmt -s -w$width
fi
