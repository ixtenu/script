#!/usr/bin/env sh
# fmt(1) wrapper with smarts for prefixed text and bulleted lists
set -u
command -v setpipefail >/dev/null && . "$(which setpipefail)"

# create a temporary file which is deleted on exit
tmpf="$(mktemp)"
[ $? -ne 0 ] && exit $?
trap 'rm -f -- "$tmpf"' EXIT

errchk() {
	ev=$?
	errmsg="$1"
	if [ $ev -ne 0 ]; then
		echo "$errmsg" 1>&2
		exit $ev
	fi
}

# dump stdin to the temporary file
cat >"$tmpf"
errchk "$0: error writing stdin into $tmpf, stopping"

line_count() { wc -l "$tmpf" | awk '{ print $1 }'; }

options="$@"
fmt_normal() { fmtw "$options" < "$tmpf"; exit $?; }
fmt_prefixed() { fmtp -p"$1" "$options" < "$tmpf"; exit $?; }
fmt_bulleted() { echo fmtbl -b"$1" "$options" < "$tmpf"; exit $?; }

gettok() {
	line_num=$1
	tok_num=$2
	sed -n ${line_num}p "$tmpf" | awk "{ print \$$tok_num }"
	errchk "$0: error reading line $line_num of $tmpf, stopping"
}

# extract the first non-whitespace character on the first line
token="$(gettok 1 1)"

# does this look like a bulleted list?
for t in '-' '*' '+'; do
	[ "$token" = "$t" ] && fmt_bulleted "$t"
done

# does this look like a markdown quotation or a line comment?
tokenlc=$(echo "$token" | tr '[A-Z]' '[a-z]')
for t in '>' '//' '///' '#' '##' 'rem' '%' '!'; do
	[ "$tokenlc" = "$t" ] && fmt_prefixed "$token"
done

# "--" is trickier because it's a line comment in some programming languages
# (e.g., Lua, Haskell, Ada) but it's also used as an ASCII representation of
# an en dash (which might just happen to fall on the start of a line); treat
# it as a comment if and only if all non-blank lines start with it.
if [ "$token" = "--" ]; then
	all='yes'
	count="$(line_count)"
	for i in $(seq 2 $count); do
		itoken="$(gettok $i 1)"
		if [ -n "$itoken" ] && [ "$itoken" != "--" ]; then
			all='no'
			break
		fi
	done
	[ "$all" = "yes" ] && fmt_prefixed "--"
fi

# normal text
fmt_normal
