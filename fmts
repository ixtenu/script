#!/usr/bin/env sh
# fmt(1) wrapper with smarts for prefixed text and bulleted lists
set -u
command -v setpipefail >/dev/null && . "$(which setpipefail)"

# create a temporary file which is deleted on exit
tmpf="$(mktemp)"
if [ $? -ne 0 ]; then
	exit $?
fi
trap 'rm -f -- "$tmpf"' EXIT

# dump stdin to the temporary file
cat >"$tmpf"
if [ $? -ne 0 ]; then
	ev=$?
	echo "$0: error writing stdin into $tmpf, stopping" 1>&2
	exit $ev
fi

# extract the first non-whitespace character on the first line
token="$(sed 1q "$tmpf" | awk '{ print $1 }')"
if [ $? -ne 0 ]; then
	ev=$?
	echo "$0: error reading first line of $tmpf, stopping" 1>&2
	exit $ev
fi

# does this look like a bulleted list?
for t in '-' '*' '+'; do
	if [ "$token" = "$t" ]; then
		cat "$tmpf" | fmtbl -b"$t" "$@"
		exit $?
	fi
done

# does this look like a markdown quotation or a line comment?
tokenlc=$(echo "$token" | tr '[A-Z]' '[a-z]')
for t in '>' '//' '///' '#' '##' 'rem' '%' '!'; do
	if [ "$tokenlc" = "$t" ]; then
		cat "$tmpf" | fmtp -p"$token" "$@"
		exit $?
	fi
done

# "--" is trickier because it's a line comment in some programming languages
# (e.g., Lua, Haskell, Ada) but it's also used as an ASCII representation of
# an en dash (which might just happen to fall on the start of a line); treat
# it as a comment if and only if all non-blank lines start with it.
if [ "$token" = "--" ]; then
        all='yes'
        count="$(wc -l "$tmpf" | awk '{print $1 }')"
        for i in $(seq 2 $count); do
                itoken="$(sed -n ${i}p "$tmpf" | awk '{ print $1 }')"
                if [ -n "$itoken" ] && [ "$itoken" != "--" ]; then
                        all='no'
                        break
                fi
        done
        if [ "$all" = "yes" ]; then
                cat "$tmpf" | fmtp -p"$token" "$@"
                exit $?
        fi
fi

# normal text
cat "$tmpf" | fmtw "$@"
